#!/usr/bin/env python

'''
  Tool to upload data to sqlite Database 
  @author - Ankur Srivastava
  Date - 05 January 2015 
'''
import logging
import sys

LOG = logging.Logger("FLASK_DB_UPLOAD")

streamHandler = logging.StreamHandler(sys.stdout)
logFormat = logging.Formatter('%(asctime)s|%(name)s|%(levelname)s|%(lineno)d|%(message)s')
streamHandler.setFormatter(logFormat)

LOG.addHandler(streamHandler)
LOG.setLevel(logging.INFO)

LOG.info('Logging started')

# Class to hold the TestResults object
class TestResultsModel(object):
    def __init__(self,release, version, component, id, testrun, status, description):
        self.release     = release
        self.version     = version
        self.component   = component
        self.id          = id
        self.testrun     = testrun
        self.status      = status
        self.description = description

    # Returns the testresults as dictionary of items
    def asDict(self):
        testresults = {
           'release'     : self.release,
           'version'     : self.version,
           'component'   : self.component,
           'id'          : self.id,
           'testrun'     : self.testrun,
           'status'      : self.status,
           'description' : self.description
        }
        return testresults

# upload_to_db the testresults object,
# where object is a list of all testcases
def upload_to_db(testresults, database):
    '''Uploads the testresults to database all at once'''

    import sqlite3

    # TODO Need to make this configurable
    #DATABASE="/home/regression/webapp/regression.sqlite"
    LOG.debug('Connecting to database %s' %database)
    DATABASE =  database
    connection = sqlite3.connect(DATABASE)

    data = []
    # Create a list to hold all data and upload it with executemany
    for result in testresults:
        data.append((result['release'], 
            result['version'], 
            result['component'],
            result['id'], 
            result['testrun'],
            result['status'], 
            result['description']))
   
    LOG.debug(data)
    LOG.info('Total data to be uploaded = %d' %(len(data)))
    
    cursor = connection.cursor()
    cursor.executemany('''INSERT INTO 
            regression 
            VALUES(?, ?, ?, ?, ?, ?, ?)''', data)
    connection.commit()
    cursor.close()
    LOG.info('Regression results uploaded successfully')



def parserCommandLine():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input",
                        help="The Input Test Results File in text format",
                        required=True)

    parser.add_argument("-d", "--database",
                        help="The SQLite Database to connect to",
                        required=True)

    parser.add_argument("-r", "--release",
                        help="The release information",
                        required=False)
    parser.add_argument("-v", "--version",
                        help="Current version",
                        required=False)

    parser.add_argument("-c", "--component",
                        help="Component",
                        required=False)
    return parser


def process(testresultFile, rel, ver, comp):
    '''Returns testresults models as a list''' 
    l = []
    with open(testresultFile, 'r') as f:
        for line in f:
            if line.startswith("TestID") or (line.strip() == "") or line.startswith("Failed"):
                continue

            id, testrun, status, desc = line.split(",",3)
            l.append(TestResultsModel(rel, ver, comp, id, testrun, status, desc.strip()).asDict())

    return l




def main():
    parser = parserCommandLine()
    opts = parser.parse_args()

    infile  = opts.input
    rel = opts.release
    ver = opts.version
    comp = opts.component
    database = opts.database

    if not rel:
        rel = "NA"

    if not ver:
        ver = "NA"

    if not comp:
        comp = "NA"


    LOG.debug('Release = %s, Version = %s, Component = %s, Database = %s',
            rel, ver, comp, database)
    upload_to_db(process(infile, rel, ver, comp), database)


if __name__ == "__main__":
    main()

