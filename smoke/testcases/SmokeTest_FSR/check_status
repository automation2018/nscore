#!/usr/bin/env bash
# Generated by: needle
#    Date Time: 11/23/16 05:05:09 AM
#  Description: Check status to validate cases for smoke
# 
# Conventions
#   1. Two(2) space indentation. No tabs
#   2. Variables and function starts with snake_case
#		3. Constants are declared with ALL_CAPS

# Source out required files
# Default Constants
source $NS_WDIR/lib/automation_util

PATH_TO_TEST_RUN="$NS_WDIR/logs/TR$(get_testidx)"
#PARTITION_PATH="${PATH_TO_TEST_RUN}/$(get_test_partition)"
PROGRESS_REPORT_FILE="${PATH_TO_TEST_RUN}/progress.report"
SUMMARY_GDF_FILE="${PATH_TO_TEST_RUN}/summary_gdf.data"
#EVENT_LOG_FILE="${PARTITION_PATH}/event.log"
#MONITOR_LOG_FILE="${PARTITION_PATH}/monitor.log"
GLOBAL_DAT_FILE="${PATH_TO_TEST_RUN}/global.dat"
SCENARIO_FILE="${PATH_TO_TEST_RUN}/scenario"

# Entry point to check status
# Add cases to handle your validation
function main() {
	case $(get_tname) in
    "SMOKE-053-001") handle_fsr_1_case ;;
    "SMOKE-053-002") handle_fsr_2_case ;;
    "SMOKE-053-003") handle_fsr_3_case ;;
    "SMOKE-053-004") handle_fsr_4_case ;;
    "SMOKE-053-005") handle_fsr_5_case ;;
    "SMOKE-053-006") handle_fsr_6_case ;;
    "SMOKE-053-007") handle_fsr_7_case ;;
    "SMOKE-053-008") handle_fsr_8_case ;;

# End case def
		*) handle_unknown_case ;;
		?) handle_unknown_case ;;
  esac
}

# Helper function to log status
# Sets additional product id and
# category id
function handle_unknown_case() {
	log_status_and_exit_ex "FAIL" "Testcase name not found"
}

# TODO: 
# 1. Add logic to validate case FSR_1
# 2. Depending upon evaluation update the status with your own description

function handle_fsr_1_case(){
    handle_all_cases
}

function handle_fsr_2_case(){
    handle_all_cases
}

function handle_fsr_3_case(){
    handle_all_cases
}

function handle_fsr_4_case(){
    handle_all_cases
}

function handle_fsr_5_case(){
    handle_all_cases
}

function handle_fsr_6_case(){
    handle_all_cases
}

function handle_fsr_7_case(){
    handle_all_cases
}

function handle_fsr_8_case(){
    handle_all_cases
}
function handle_all_cases() {
  debug_log "started handling" 
  #Getting expected phase timings
  RESULTS_CSV="$NS_WDIR/logs/tsr/${TEST_CYCLE_NUM}/${TSR_NUM}/SmokeTest_FSR_results.csv"
  RAMP_UP_SEQUENCE=$(cut -d ',' -f 6 ${RESULTS_CSV}|tail -1)
  DURATION_SEQUENCE=$(cut -d ',' -f 7 ${RESULTS_CSV}|tail -1)
  RAMP_DOWN_SEQUENCE=$(cut -d ',' -f 8 ${RESULTS_CSV}|tail -1)
  debug_log "ramp up sequence $RAMP_UP_SEQUENCE"
  ramp_up_steps_expected=$(get_expected_num_of_steps "${RAMP_UP_SEQUENCE}")
  debug_log "ramp down sequence $RAMP_DOWN_SEQUENCE"
  ramp_down_steps_expected=$(get_expected_num_of_steps "${RAMP_DOWN_SEQUENCE}")

  echo "ramp up steps expected: $ramp_up_steps_expected"
  echo "ramp down steps expected: $ramp_down_steps_expected"

  #Obtaining no. of steps taken to ramp_up and ramp_down
  ramp_up_steps=$(($(grep -c "RAMPING UP" ${PROGRESS_REPORT_FILE})+1))
  ramp_down_steps=$(($(grep -c "RAMPING DOWN" ${PROGRESS_REPORT_FILE})+1))

  #Comparing number of steps taken and expected 
  if [ $ramp_up_steps -ne $ramp_up_steps_expected ];then
      log_status_and_exit_ex "FAIL" "FSR-Test case failed because ramp up steps taken were: $ramp_up_steps and the expected number of steps were: $ramp_up_steps_expected did not match"
  elif [ $ramp_down_steps -ne $ramp_down_steps_expected ];then
      log_status_and_exit_ex "FAIL" "FSR-Test case failed because ramp down steps taken were: $ramp_down_steps and the expected number of steps were: $ramp_down_steps_expected did not match"
  fi
  
  phase_timing_estimator "$RAMP_UP_SEQUENCE" "$DURATION_SEQUENCE" "$RAMP_DOWN_SEQUENCE"
#  echo "${phase_timings_estimation[@]}"
 
  phase_names=("Start phase begin" "Start phase end" "Ramp Up phase begin" "Ramp Up phase end" "Duration phase begin" "Duration phase end" "Ramp Down phase begin" "Ramp Down phase end")

  phase_timings_found[0]=$(grep "PHASE_START_TIME START" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[1]=$(grep "PHASE_END_TIME START" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[2]=$(grep "PHASE_START_TIME RAMP_UP" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[3]=$(grep "PHASE_END_TIME RAMP_UP" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[4]=$(grep "PHASE_START_TIME DURATION" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[5]=$(grep "PHASE_END_TIME DURATION" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[6]=$(grep "PHASE_START_TIME RAMP_DOWN" ${GLOBAL_DAT_FILE}|awk '{print $4}')
  phase_timings_found[7]=$(grep "PHASE_END_TIME RAMP_DOWN" ${GLOBAL_DAT_FILE}|awk '{print $4}')

  echo "According to current test run"
  echo "Ramp up started at : ${phase_timings_found[2]}"
  echo "Ramp up ended at: ${phase_timings_found[3]}"
  echo "Duration started at: ${phase_timings_found[4]}"
  echo "Duration ended at: ${phase_timings_found[5]}"
  echo "RampDown started at: ${phase_timings_found[6]}"
  echo "RampDown ended at: ${phase_timings_found[7]}"
 echo "val 1 ${phase_timings[0]}"
 echo "val 2 ${phase_timings[1]}"
  for((i=0; i<=7; i++)){
      echo "Check: ${phase_timings_found[i]} and ${phase_timings[i]}"
      if [ ${phase_timings_found[i]} != ${phase_timings[i]} ];then
          found_timing_in_sec=$(echo ${phase_timings_found[i]} | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
          expected_timing_in_sec=$(echo ${phase_timings[i]} | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
          diff=$(($found_timing_in_sec-$expected_timing_in_sec))
          echo "Difference found in seconds: $diff"
          diff_pct=$(($diff*100/$expected_timing_in_sec))
          echo "diff_pct found: $diff_pct"
          if [ $diff_pct -lt -10 ] || [ $diff_pct -gt 10 ];then
              if [ $diff -ne 1 ];then
                  log_status_and_exit_ex "FAIL" "FSR - Test case failed because found and expected values for ${phase_names[i]} timing do not match"
              fi
          fi
      fi
  }
  log_status_and_exit_ex "PASS" "FSR - Testcase passed"
}

# Following function return the estimated time of start and completion of any phase. It takes two arguments:
#    Argument 1: phase_name : An integer representing the phase whose timing is to be estimated.
#                             0 - start
#                             1 - rampup
#                             2 - duration
#                             3 - rampdown
#    Argument 2: phase_sequence : A sequence given in scenario as phase settings.

function phase_timing_estimator(){
    ramp_up_sequence=$1
    duration_sequence=$2
    ramp_down_sequence=$3
    
    #Setting start phase begin-end timings to 00:00:02 each as start phase is not given
    phase_timings[0]="00:00:02"
    phase_timings[1]="00:00:02"
    
    #Setting rampup phase begin as 00:00:02 and end as 00:00:02 + given in scenario
    phase_timings[2]="00:00:02"
    if [ $(echo ${ramp_up_sequence}|cut -d ' ' -f 2) == "IMMEDIATELY" ];then
        ramp_up_end="00:00:02"
    elif [ $(echo ${ramp_up_sequence}|cut -d ' ' -f 2) == "TIME_SESSIONS" ];then
        rampup_timing_in_sec=$(echo $(echo $ramp_up_sequence|cut -d ' ' -f 3) | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
        ramp_up_end=$(date '+%H:%M:%S' --date="${phase_timings[2]} IST + ${rampup_timing_in_sec} seconds")
    fi
    phase_timings[3]=${ramp_up_end}
    
    #Setting duration phase begin equal to ramp up end time and end as given in scenario
    phase_timings[4]=${ramp_up_end}
    duration_timing_in_sec=$(echo $(echo $duration_sequence|cut -d ' ' -f 2) | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
    echo "Duration timing in sec is $duration_timing_in_sec"
    phase_timings[5]=$(date '+%H:%M:%S' --date="${phase_timings[4]} IST + ${duration_timing_in_sec} seconds")
    
    #Setting rampdown phase begin equal to duration phase end and end acc to scenario
    phase_timings[6]=${phase_timings[5]}
    if [ $(echo ${ramp_down_sequence}|cut -d ' ' -f 2) == "IMMEDIATELY" ];then
        ramp_down_end="${phase_timings[5]}"
    elif [ $(echo ${ramp_down_sequence}|cut -d ' ' -f 2) == "TIME_SESSIONS" ];then
        rampdown_timing_in_sec=$(echo $(echo $ramp_down_sequence|cut -d ' ' -f 3) | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
        ramp_down_end=$(date '+%H:%M:%S' --date="${phase_timings[6]} IST + ${rampdown_timing_in_sec} seconds")
    fi
    phase_timings[7]=$ramp_down_end

    export phase_timings
 #   echo ${phase_timings[@]}
}

function get_expected_num_of_steps(){
    target_sequence="$1"
    debug_log "Target is $target_sequence"
    if [ $(echo ${target_sequence}|cut -d ' ' -f 2) == "IMMEDIATELY" ];then
        steps=1
    elif [ $(echo ${target_sequence}|cut -d ' ' -f 2) == "TIME_SESSIONS" ];then
        num_of_seconds=$(echo $(echo $target_sequence|cut -d ' ' -f 3) | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
        if [ $(echo ${target_sequence}|cut -d ' ' -f 4) -eq 0 ];then
            if [ $num_of_seconds -le 60 ];then
                steps=2
            else
                steps=$((${num_of_seconds}/60))
            fi
        elif [ $(echo ${target_sequence}|cut -d ' ' -f 4) -eq 1 ];then
            steps=$((${num_of_seconds}/$(echo ${target_sequence}|cut -d ' ' -f 5)))
        elif [ $(echo ${target_sequence}|cut -d ' ' -f 4) -eq 2 ];then
            steps=$(echo ${target_sequence}|cut -d ' ' -f 5)
        fi
    fi
    echo $steps
}

# Call to main function
# Do not override it
main
