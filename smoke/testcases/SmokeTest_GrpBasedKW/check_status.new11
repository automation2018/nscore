#!/usr/bin/env bash

source $NS_WDIR/lib/automation_util

TR_PATH="/home/netstorm/work/logs/TR${T_RUN_ID}"
S_FILE="/home/netstorm/work/logs/TR${T_RUN_ID}/scenario"
P_FILE="/home/netstorm/work/logs/TR${T_RUN_ID}/progress.report"
REQ_FILE="${T_ID_REQ_PATH}/url_req_0_0_0_0_0_0_0_0_0.dat"
EVENT_LOG="$NS_WDIR/logs/TR$T_RUN_ID/$(get_test_partition)/event.log"
SCRIPT_PATH="$NS_WDIR/logs/TR$T_RUN_ID/$(get_test_partition)/scripts"


function main(){
    case $(get_tname) in
        "SMOKE-020-001") validate_url_retry "ssl handashake" ;;
        "SMOKE-020-002") validate_url_retry "partial header" ;;
        "SMOKE-020-003") validate_url_retry "connection fail" ;;
        "SMOKE-020-004") validate_url_retry "group based and ssl handshake" ;;
        "SMOKE-020-005") validate_header "Accept";;
        "SMOKE-020-006") validate_header "Accept";;
        "SMOKE-020-007") validate_header "Host";;
        "SMOKE-020-008") validate_header "Host";;
        "SMOKE-020-009") validate_later ;;
        "SMOKE-020-010") validate_later ;; 
        "SMOKE-020-011") validate_header "User-Agent";;
        "SMOKE-020-012") validate_header "User-Agent";;
        "SMOKE-020-013") validate_header "Connection";;
        "SMOKE-020-014") validate_header "Connection";;
        "SMOKE-020-015") validate_host_header ;;
        "SMOKE-020-016") validate_host_header ;;
        "SMOKE-020-017") validate_header "Accept-Encoding";;
        "SMOKE-020-018") validate_header "Accept-Encoding";;
        "SMOKE-020-019") validate_all_header ;;
        "SMOKE-020-020") validate_all_header ;;
        "SMOKE-020-021") validate_header "Keep-Alive";;
        "SMOKE-020-022") validate_header "Keep-Alive";;     
        "SMOKE-020-023") validate_cont_on_page_error_mode_0 ;;     
        "SMOKE-020-024") validate_cont_on_page_error_mode_1 ;;     
        "SMOKE-020-025") validate_cont_on_page_error_mode_1 ;;     
        "SMOKE-020-026") validate_cont_on_page_error_mode_1 ;;     
        "SMOKE-020-027") validate_idle_msec ;;     
        "SMOKE-020-028") validate_idle_msec ;;     
        "SMOKE-020-029") validate_idle_msec ;;     
        "SMOKE-020-030") validate_max_con_per_vuser ;;     
        "SMOKE-020-031") validate_max_con_per_vuser ;;     
        "SMOKE-020-032") validate_max_con_per_vuser ;;     
        "SMOKE-020-033") virtual_user_trace_mode_0_group ;;     
        "SMOKE-020-034") virtual_user_trace_mode_0_all ;;     
        "SMOKE-020-035") virtual_user_trace_mode_1 "G1" ;;     
        "SMOKE-020-036") virtual_user_trace_mode_1 "ALL" ;;     
        "SMOKE-020-037") virtual_user_trace_mode_2 "G1" ;;     
        "SMOKE-020-038") virtual_user_trace_mode_2 "ALL" ;;     
         *) handle_unknown_case ;;
         ?) handle_unknown_case ;;
    esac
}


function handle_unknown_case(){
    log_status_and_exit_ex "FAIL" "testcase not found"
}


function validate_url_retry(){
    param="${1}"
    max_url_retries=$(($(grep "G_MAX_URL_RETRIES" $S_FILE | awk '{print $NF}')+1))
    initiated_count=$(grep " Url  Report:" $P_FILE | awk '{print $14}'|cut -d'/' -f1)

    debug_log "max_url=$max_url_retries ; initiated_count=$initiated_count; param=${param}"

    if [ $max_url_retries -eq $initiated_count ]; then
		log_status_and_exit_ex "PASS" "max url retries for ${param} case passed;as urls retried for $(max_url_retries) times;intiated count is ${initiated_count}"
    else
		log_status_and_exit_ex "FAIL" "max url retries for ${param} case failed;as urls did not retry for $(max_url_retries) times;intiated count is ${initiated_count}"
    fi
}


function validate_header(){
    arg="${1}"
    bit=$(grep "^G_DISABLE_" "$S_FILE" | awk '{print $NF}')
    search=$(grep -o "$arg:" "$REQ_FILE")
    
	if [ $bit -eq 0 ] && [ ! -z "${search}" ];then
        debug_log "bit=$bit ; $search Header found for G_DISABLE_${arg^^}_HEADER Mode $bit"
        
		log_status_and_exit_ex "PASS" "G_DISABLE_${arg^^} ${bit} testcase passed"
    elif [ $bit -eq 1 ] && [ -z "${search}" ];then
        debug_log "bit=$bit ; $arg: Header not found for G_DISABLE_${arg^^}_HEADER Mode $bit"
        
		log_status_and_exit_ex "PASS" "G_DISABLE_${arg^^} ${bit} testcase passed"
	else
        debug_log "bit=$bit;arg=${arg};search=${search}"
        
		log_status_and_exit_ex "FAIL" "G_DISABLE_${arg^^} ${bit} testcase failed"
    fi
}


function validate_host_header(){
    bit=$(grep "^G_USE_RECORDED_HOST_IN_HOST_HDR" "$S_FILE" | awk '{print $NF}')
    host=$(grep "^SERVER_HOST" $S_FILE | awk '{print $2}')
    search=$(grep -o "Host: ${host}" "${REQ_FILE}")
    
    if [ $bit -eq 0 ] && [ -z "${search}" ];then
        debug_log "bit=$bit ; Host: $host not found for G_USE_RECORDED_HOST_IN_HOST_HDR Mode $bit"
        
		log_status_and_exit_ex "PASS" "G_USE_RECORDED_HOST_IN_HOST_HDR $bit testcase passed"
    elif [ $bit -eq 1 ] && [ ! -z "${search}" ];then
    	debug_log "bit=$bit ; $search Header found for G_USE_RECORDED_HOST_IN_HOST_HDR Mode $bit"
        
		log_status_and_exit_ex "PASS" "G_USE_RECORDED_HOST_IN_HOST_HDR $bit testcase passed"
    else
        debug_log "bit=$bit;host=${host};search=${search}"
        
		log_status_and_exit_ex "FAIL" "G_USE_RECORDED_HOST_IN_HOST_HDR $bit testcase failed"
    fi
}


function validate_later() {
    bit=$(grep "^G_DISABLE_REUSEADDR" "$S_FILE" | awk '{print $NF}')
    log_status_and_exit_ex "PASS" "G_DISABLE_REUSEADDR $bit smoke test validation passed"
}


function validate_all_header(){
    bit=$(grep "^G_DISABLE_" "$S_FILE" | awk '{print $NF}')
    search=$(grep ": " "$REQ_FILE")
	
	if [ $bit -eq 0 ] && [ ! -z "$search" ];then
	   debug_log "bit=$bit ; Headers are there for G_DISABLE_ALL_HEADER Mode $bit"
	   
	   log_status_and_exit_ex "PASS" "G_DISABLE_ALL_HEADER $bit testcase passed"
	elif [ $bit -eq 1 ] && [ -z "$search" ];then
	   debug_log "bit=$bit ; Headers are not there for G_DISABLE_ALL_HEADER Mode $bit"
	   
	   log_status_and_exit_ex "PASS" "G_DISABLE_ALL_HEADER $bit testcase passed"
	else
	   debug_log "bit=$bit;search=${search}"
	   
	   log_status_and_exit_ex "FAIL" "G_DISABLE_ALL_HEADER $bit testcase failed"
	fi

}


# find the group, script, page where keyword applied
# total pages included : total pages in each script
# total pages expected : after keyword applied 
function validate_cont_on_page_error_mode_0(){
    name_of_scripts=$(grep "^SGRP " ${S_FILE} | cut -d' ' -f6)
	no_of_scripts=$(grep "^SGRP " ${S_FILE} | cut -d' ' -f6|wc -l)
	
	total_pages_included=0
	for ((i=1;i<=${no_of_scripts};i++))
	do
		script_name=$(echo $name_of_scripts | cut -d' ' -f"$i")
		no_of_pages=$(grep -c "^ *ns_web_url" "${SCRIPT_PATH}/${script_name}/flow.c")
        total_pages_included=$((total_pages_included + no_of_pages ))
	done
	
	debug_log "total_pages_included=$total_pages_included"

	# get info from keyword and get count of pages not included
	flag=0
	kw_group=$(grep "^G_CONTINUE_ON_PAGE_ERROR" ${S_FILE} | cut -d ' ' -f2)
	if [ "$kw_group" != "ALL" ];then
		kw_page=$(grep "^G_CONTINUE_ON_PAGE_ERROR" ${S_FILE} | cut -d ' ' -f3)
		if [ "$kw_page" != "ALL" ];then
			
			kw_script=$(grep "^SGRP $kw_group" ${S_FILE} | cut -d ' ' -f6)
			pages=(`grep "ns_web_url" "${SCRIPT_PATH}/${kw_script}/flow.c" | cut -d "\"" -f2`)
			total=${#pages[@]}
            
			for i in "${!pages[@]}"; do
				if [[ "${pages[$i]}" = "${kw_page}" ]]; then
					flag=$((i + 1))
					not_include_page_count=$((total - flag))
					break
			    fi
		    done
		fi	
    fi

	debug_log "flag=$flag;not_include_page_count=$not_include_page_count"
	
	actual_url_fail=$(grep "Url  Report:" ${P_FILE} | egrep -o "[45]xx: [0-9]+" | cut -d ' ' -f2)
	expected_ur_fail=$((total_pages_included - not_include_page_count))

    debug_log "actual_url_fail=$actual_url_fail; expected_ur_fail=$expected_ur_fail"

	if [ $actual_url_fail -eq $expected_ur_fail ]; then
        log_status_and_exit_ex "PASS" "continue on page error mode 0 validation passed"
	else
        log_status_and_exit_ex "FAIL" "continue on page error mode 0 validation failed"
	fi
}


# number of url fail event logged, 
# number of url failed,
# number of pages failed should be equal
function validate_cont_on_page_error_mode_1(){
    url_fail_events_count=$(grep -c "Url failed with status 4xx" ${EVENT_LOG})
	url_fail_count=$(grep "Url  Report:" ${P_FILE} | egrep -o "[1-5]xx: [0-9]+" | cut -d ' ' -f2)
	page_fail_count=$(grep "Page  Report:" ${P_FILE} | egrep -o "[1-5]xx: [0-9]+" | cut -d ' ' -f2)
	
	debug_log "url_fail_events_count=$url_fail_events_count;url_fail_count=$url_fail_count;page_fail_count=$page_fail_count"
	
	if [ $url_fail_events_count -eq $url_fail_count ] && [ $url_fail_events_count -eq $page_fail_count ]; then
        log_status_and_exit_ex "PASS" "continue on page error mode 1 validation passed"
    else
		log_status_and_exit_ex "FAIL" "continue on page error mode 1 validation failed"
    fi
}

function validate_idle_msec(){
    TIMEOUT_URL_TIME=50
	idle_time=$(grep "^G_IDLE_MSECS" $S_FILE | awk '{print $NF}')
	idle_time_sec=$((idle_time / 1000))
	group=$(grep "^G_IDLE_MSECS" $S_FILE | awk '{print $2}')
	no_of_timeout_url=$(grep "Url  Report:" $P_FILE | awk -F'/' '{print $3}'|awk '{print $NF}')
	no_of_succ_url=$(grep "Url  Report:" $P_FILE | awk -F'/' '{print $2}'|awk '{print $NF}')
	no_of_complete_url=$(grep "Url  Report:" $P_FILE | awk -F'/' '{print $1}'|awk '{print $NF}')
	debug_log "TIMEOUT_URL_TIME=$TIMEOUT_URL_TIME;idle_time_sec=$idle_time_sec;group=$group;no_of_timeout_url=$no_of_timeout_url;no_of_succ_url=$no_of_succ_url;no_of_complete_url=$no_of_complete_url"

	# 2 urls 1 suceess + 1 url under test
	# svc time > idle time
    if [ $idle_time_sec -gt $TIMEOUT_URL_TIME ];then 	
		# also check test run time should be less than equals service time
		if [ $no_of_succ_url -eq 2 ]; then
			debug_log "pass "
	        log_status_and_exit_ex "PASS" "idle msec testcase validation passed"
		else
			debug_log "fail"
	        log_status_and_exit_ex "FAIL" "idle msec testcase validation failed"
		fi
	elif [ $no_of_timeout_url -eq 1 ]; then
        # also check test run time should be greater than equals to service time
		debug_log "pass "
	    log_status_and_exit_ex "PASS" "idle msec testcase validation passed"
	else
        debug_log "fail"
	     log_status_and_exit_ex "FAIL" "idle msec testcase validation failed"
	 fi

}

function validate_max_con_per_vuser(){
	no_of_vuser=$(grep "^G_MAX_CON_PER_VUSER" $S_FILE |awk '{print $NF}')
	group_with_keyword=$(grep "^G_MAX_CON_PER_VUSER" $S_FILE | awk '{print $2}')
	
	if [ $group_with_keyword != "ALL" ];then
		script_name=$(grep "^SGRP $group_with_keyword" $S_FILE | awk '{print $(NF-1)}')
		total_url_in_script=$(grep -c "URL=http:" ${SCRIPT_PATH}/${script_name}/flow.c)
		total_main_url=$(grep -c "ns_web_url" ${SCRIPT_PATH}/${script_name}/flow.c)
		total_url_of_conn=$((total_url_in_script - total_main_url))
		if [ $total_url_of_conn -eq 0 ];then
            total_url_of_conn=1
        fi
							
		no_of_user=$(grep "^SGRP $group_with_keyword" $S_FILE | awk '{print $NF}')
		no_of_connection=$(grep "Total(Open" $P_FILE | sed -n 2p| awk '{print $NF}'| tr -cd [:digit:])
		no_of_session=$(grep "^SCHEDULE" $S_FILE | awk '{print $NF}')
		total_script=$(grep -c "^SGRP" $S_FILE)
		total_script_with_keyword=$(grep -c "^G_MAX_CON_PER_VUSER" $S_FILE)
		total_script_without_keyword=$((total_script - total_script_with_keyword))

		debug_log "no_of_vuser=$no_of_vuser; group_with_keyword=$group_with_keyword; script_name=$script_name; total_url_in_script=$total_url_in_script; no_of_user=$no_of_user; no_of_connection=$no_of_connection; no_of_session=$no_of_session"

		if [ $no_of_vuser -le $total_url_of_conn ];then

			no_of_expect_conn=$((no_of_vuser * no_of_user + total_script_without_keyword))
			debug_log "no_of_expect_conn=$no_of_expect_conn"
			if [ $no_of_expect_conn -eq $no_of_connection ];then
				debug_log "no. of expect connection is equal to the exact no. of connection"
				log_status_and_exit_ex "PASS" "max con per vuser testcase passed;as no of expect connection is equal to the exact no of connection"
            else
				log_status_and_exit_ex "FAIL" "max con per vuser testcase failed;as no of expect connection is not equal to the exact no of connection"

			fi
		elif [ $no_of_vuser -gt $total_url_of_conn ];then
			no_of_expect_conn=$((total_url_of_conn * no_of_user + total_script_without_keyword))
			debug_log "no_of_expect_conn=$no_of_expect_conn"
			if [ $no_of_expect_conn -eq $no_of_connection ];then
				debug_log "no. of expect connection is equal to the exact no. of connection"
				log_status_and_exit_ex "PASS" "max con per vuser testcase passed;as no of expect connection is equal to the exact no of connection"
			fi

		else	
			debug_log "no. of expect connection is not equal to the exact no. of connection"
			log_status_and_exit_ex "FAIL" "max con per vuser testcase failed;as no of expect connection is not equal to the exact no of connection"
		fi
	else
		total_script=$(grep -c "^SGRP" $S_FILE)
		script_name=$(grep "^SGRP" $S_FILE|awk '{print $6}')
		total_url_in_script=0
		total_main_url=0
		total_of_expect_conn=0
  		debug_log "total_script=$total_script; script_name=$script_name"

		for ((i=1;i<=$total_script;i++));do
			script=$(cut -d' ' -f"$i" <<< $script_name)
			total_url_in_script=$(grep -c "URL=http:" "$SCRIPT_PATH/$script/flow.c")
			total_main_url=$(grep -c "ns_web_url" "$SCRIPT_PATH/$script/flow.c")
			total_url_of_conn=$((total_url_in_script - total_main_url))
			if [ $total_url_of_conn -eq 0 ];then
				total_url_of_conn=1
			fi
		    no_of_user=$(grep "^SGRP.*$script" $S_FILE | awk '{print $NF}')	
			debug_log "script=$script;total_url_in_script=$total_url_in_script;total_main_url=$total_main_url;total_url_of_conn=$total_url_of_conn;no_of_user=$no_of_user"
			if [ $no_of_vuser -le $total_url_of_conn ];then

				no_of_expect_conn=$((no_of_vuser * no_of_user))

				debug_log "no_of_expect_conn in $script script=$no_of_expect_conn"
			elif [ $no_of_vuser -gt $total_url_of_conn ];then
				no_of_expect_conn=$((total_url_of_conn * no_of_user ))
				debug_log "no_of_expect_conn in $script script=$no_of_expect_conn"

			else	
				debug_log "no. of expect connection is not found"
			fi
			total_of_expect_conn=$((no_of_expect_conn + total_of_expect_conn))
		done

		no_of_connection=$(grep "Total(Open" $P_FILE | sed -n 2p| awk '{print $NF}'| tr -cd [:digit:])
		debug_log "no_of_connection=$no_of_connection; total_of_expect_conn=$total_of_expect_conn"
		if [ $no_of_connection -eq $total_of_expect_conn ];then
			debug_log "no. of expect connection is equal to the exact no. of connection"
            log_status_and_exit_ex "PASS" "max con per vuser testcase passed;as no of expect connection is equal to the exact no of connection"
		else
			debug_log "no. of expect connection is not equal to the exact no. of connection"
			log_status_and_exit_ex "PASS" "max con per vuser testcase failed;as no of expect connection is not equal to the exact no of connection"
		fi
	fi
}

function check_tr_vuser_dir(){
    group=$1
    debug_log "trace directory = ${TR_PATH}/vuser_trace/${group}*"
    trace_directory="${TR_PATH}/vuser_trace/${group}*"
    if ls trace_directory &> /dev/null ; then 
       echo 0
    else
       echo 1
    fi

}

function vuser_tracing_tool_status(){
    group=$1
    if [ -z "$(grep 'Vuser tracing is not enabled for group = ${group}' /tmp/virtual_user_trace.log)" ];then
      echo 0
    else
      echo 1
    fi
}

###Virtual user trace feature mode 0#####
function virtual_user_trace_mode_0(){
    group=$1
    dir_status_g1=$(check_tr_vuser_dir G1)
    tool_status_g1=$(vuser_tracing_tool_status G1)
    dir_status_g2=$(check_tr_vuser_dir G2)
    tool_status_g2=$(vuser_tracing_tool_status G2)
    if [ $group != "ALL" ];then
      if [ $dir_status_g1 -eq 1  ] && [ $tool_status_g1 -eq 1 ] &&\
	 [ $dir_status_g2 -eq 1  ] && [ $tool_status_g2 -eq 0 ]
	  log_status_and_exit_ex "PASS" "Virtual user tracing mode 0 ${group} passed as no vuser_trace directory found in testrun"
      else
	  log_status_and_exit_ex "FAIL" "Virtual user tracing mode 0 ${group} passed as vuser_trace directory found in testrun"
      fi
    
    else
      if [ $dir_status_g1 -eq 1  ] && [ $tool_status_g1 -eq 1 ] &&\
	 [ $dir_status_g2 -eq 1  ] && [ $tool_status_g2 -eq 0 ]
	  log_status_and_exit_ex "PASS" "Virtual user tracing mode 0 ${group} passed as no vuser_trace directory found in testrun"
      else
	  log_status_and_exit_ex "FAIL" "Virtual user tracing mode 0 ${group} passed as vuser_trace directory found in testrun"
      fi

    fi

}

###Virtual user trace feature mode 1#####
function virtual_user_trace_mode_1(){
echo $1

}


###Virtual user trace feature mode 2#####
function virtual_user_trace_mode_2(){
echo $1

}
main


exit 0
